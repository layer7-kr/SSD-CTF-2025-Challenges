# 차이의 합
#### 출제자 : 김승철 / seuch10
## Concept
- 애드혹, 구현
## Writeup
설명을 위해 여러가지 배열과 수들에 대해 정의합시다.

임의의 정수 P와 Q에 대하여 P/Q를 P를 Q로 나누었을 때 몫이라고 가정하여 설명합니다.
배열 B를 배열 A를 오름차순으로 정렬한 배열이라고 정의합시다. 그리고 D[i]를 B의 i번째 원소와 i+1번째 원소의 차라고 합시다. S를 B를 재배열했을 때 인접한 원소의 차의 합이라고 정의합시다. 그리고 B[i]와 B[j]를 인접하게 재배열하면 D[i]부터 D[j-1]까지를 횡단했다고 가정했을 때 T[i]를 D[i]를 횡단한 횟수라고 합시다. 

이때, T[i]의 최댓값은 min(i,N−i)*2를 만족합니다. 다만 N이 짝수이면서 i가 N/2일 때 T[i]의 최댓값은 N-1을 만족합니다. 또한 S는 i가 1부터 N까지 T[i]*𝐷[𝑖]를 더한 값과 같습니다. 따라서 1부터 N사이의 모든 정수 𝑖에 대하여 T[i]가 최대가 될 때 S 또한 최대가 됩니다.

첫번째로 N이 짝수일 때, 해를 다음과 같이 구성할 수 있습니다.
𝐵[𝑁/2]으로 시작하고 𝐵[𝑁/2+1]으로 끝나며 P = {𝐵[𝑖] | 𝑖 > N/2+1}의 원소와 Q = {𝐵[𝑖] | 𝑖 < N/2}의 원소가 겹치지 않고 번갈아 존재하도록 재배열했을 때 S가 최대가 됩니다. 예를 들어 B = {1, 2, 3, 4}일 때 새로운 배열 R을 {2, 4, 1, 3}와 같이 재배열 할 때 S가 최대가 됩니다.

두번째로 N이 홀수일 때, 해를 다음과 같이 구성할 수 있습니다. T[i]는 N이 홀수일 때 모든 T[i]를 최대로 만드는 재배열 방법이 존재하지 않습니다. 다만 T[𝑁/2] 혹은 T[𝑁/2+1]를 제외한 모든 T[i]를 최대로 만들 때 S가 최대가 됩니다. 
만약 𝐷𝑁/2이 𝐷𝑁/2+2 보다 크거나 같다면 𝐵𝑁/2+1으로 시작하고 𝐵𝑁/2+2으로 끝나며 P = {𝐵[𝑖] | 𝑖 > N/2+2}의 원소와 Q = {𝐵[𝑖] | 𝑖 < N/2+1}의 원소가 겹치지 않고 번갈아 존재하도록 재배열했을 때 S가 최대가 됩니다. 이 때 T[𝑁/2]은 N-1입니다. 예를 들어 B = {1, 2, 4, 5, 6}일 때 새로운 배열 R을 {4, 1, 6, 2, 5}와 같이 재배열 할 때 S가 최대가 됩니다.
만약 𝐷[𝑁/2]이 𝐷[𝑁/2+2] 보다 작다면 𝐵[𝑁/2+1]으로 시작하고 𝐵[𝑁/2]으로 끝나며 P = {𝐵[𝑖] | 𝑖 < N/2}의 원소와 Q = {𝐵𝑖 | 𝑖 > N/2+1}의 원소가 겹치지 않고 번갈아 존재하도록 재배열했을 때 𝐵 배열의 S가 최대가 됩니다. 이 때 T[𝑁/2+1]은 N+1입니다. 예를 들어 B = {1, 2, 3, 5, 6}일 때 새로운 배열 R을 {3, 5, 1, 6, 2}와 같이 재배열 할 때 S가 최대가 됩니다.

## ex.c
```c
#include <stdio.h>
#include <stdlib.h>

typedef long long ll;

int compare(const void *a, const void *b) {
    int num1 = *(const int *)a;
    int num2 = *(const int *)b;

    if (num1 < num2) return -1;
    if (num1 > num2) return 1;   
    return 0;                   
}

int main()
{
    int N;
    ll list[200000];
    scanf("%d", &N);
    for(int i = 0; i < N; i++)
    {
        scanf("%lld", &list[i]);
    }
    qsort(list, N, sizeof(ll), compare);
    ll sum = 0;
    for(ll i = 0; i < N-1; i++)
    {
        if(i%2 == 0)
        {
            sum += (list[i/2+1]-list[i/2])*((i/2+1)*2);
        }
        else
        {
            sum += (list[N-i/2-1]-list[N-i/2-2])*((i/2+1)*2);
        }
    }
    if(N%2 == 0)
    {
        sum -= list[N/2]-list[N/2-1];
    }
    else
    {
        if(list[N/2+1]-list[N/2] > list[N/2]-list[N/2-1])
        {
            sum -= list[N/2]-list[N/2-1];
        }
        else
        {
            sum -= list[N/2+1]-list[N/2];
        }
    }
    printf("%lld\n", sum);
}
```