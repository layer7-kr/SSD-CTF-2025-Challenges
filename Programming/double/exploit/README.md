
# double

#### 출제자 : 조수호 / shielder

## Concept

- 분할 정복, 수학

## Writeup

`n`이 굉장히 크기 때문에 부동소수점 문제로 $(a+\sqrt{b})^n$을 정확히 계산할 수 없습니다. 따라서 단순히 `double`을 사용한다고 해결할 수 있는 문제가 아닙니다. 이를 정확히 계산하기 위해선 루트를 계산하지 않아도 되는 방법이 필요합니다.

$A_n = (a+\sqrt{b})^n + (a-\sqrt{b})^n$라고 정의합시다. 이항정리에 따라 $A_n$은 정수이며, 그 값은 $(a+\sqrt{b})^n$의 정수 부분의 두 배입니다. 조건에서 $(a-1)^2 < b < a^2$라고 하였으므로 $(a-\sqrt{b}) < 1$이고, $(a-\sqrt{b})^n < 1$입니다. 따라서 $\lfloor (a+\sqrt{b})^n \rfloor = 2 * ((a+\sqrt{b})^n의\ 정수 \ 부분) - 1$입니다.

$(a+\sqrt{b})^n = X_n+Y_n\sqrt{b}$으로 정의하겠습니다. $X_{n+1}+Y_{n+1}\sqrt{b} = (a+\sqrt{b})(X_n+Y_n\sqrt{b})=(aX_n+bY_n)+(X_n+aY_n)\sqrt{3}$이므로 $X_{n+1} = aX_n+b,Y_{n+1}=X_n+aY_n$입니다. 따라서
$$
\begin{pmatrix}
X_{n+1} \\
Y_{n+1}
\end{pmatrix}
{=}
\begin{pmatrix}
a & b \\
1 & a
\end{pmatrix}
\begin{pmatrix}
X_{n} \\
Y_{n}
\end{pmatrix}
$$
이고, 귀납적 과정에 의해
$$
\begin{pmatrix}
X_{n} \\
Y_{n}
\end{pmatrix}
{=}
\begin{pmatrix}
a & b \\
1 & a
\end{pmatrix}
^n
\begin{pmatrix}
1 \\
0
\end{pmatrix}
$$
입니다. 최종적으로 정리하자면 $\lfloor (a+\sqrt{b})^n \rfloor = 2X_n - 1$입니다. 주어지는 `n`이 매우 크지만 행렬의 거듭제곱을 계산할 수 있기 때문에 분할 정복을 이용한 거듭제곱으로 $X_n$을 구해 해결합니다.

## ex.cpp

```cpp
// compile : /usr/bin/gcc prob.c -o prob
#include <iostream>
#include <vector>
#include <cmath>
#include <cstring>
#pragma warning(disable : 4996)
#define ll long long
#define MOD 1000

using namespace std;

struct matrix
{
	ll m[2][2];
};

ll arr[101], inputa, inputb, n;
vector<matrix> v;

int main() {
    scanf("%lld %lld %lld", &inputa, &inputb, &n);

	matrix init;
	init.m[0][0] = inputa;
	init.m[0][1] = inputb;
	init.m[1][0] = 1;
	init.m[1][1] = inputa;
	v.push_back(init);
	for (ll i = 1; i <= 70; i++) {
		matrix m1 = v[i - 1], m2;
		m2.m[0][0] = ((m1.m[0][0] * m1.m[0][0]) % MOD + (m1.m[0][1] * m1.m[1][0]) % MOD) % MOD;
		m2.m[0][1] = ((m1.m[0][0] * m1.m[0][1]) % MOD + (m1.m[0][1] * m1.m[1][1]) % MOD) % MOD;
		m2.m[1][0] = ((m1.m[1][0] * m1.m[0][0]) % MOD + (m1.m[1][1] * m1.m[1][0]) % MOD) % MOD;
		m2.m[1][1] = ((m1.m[1][0] * m1.m[0][1]) % MOD + (m1.m[1][1] * m1.m[1][1]) % MOD) % MOD;
		v.push_back(m2);
	}

    memset(arr, 0, sizeof(arr));
    for (ll i = 0; i <= 70; i++) {
        arr[i] = n % 2;
        n /= 2;
    }
    ll res[2] = { 1, 0 };

    for (ll i = 0; i <= 70; i++) {
        if (!arr[i]) continue;

        ll a = ((res[0] * v[i].m[0][0]) % MOD + (res[1] * v[i].m[0][1]) % MOD) % MOD;
        ll b = ((res[0] * v[i].m[1][0]) % MOD + (res[1] * v[i].m[1][1]) % MOD) % MOD;
        res[0] = a, res[1] = b;
        while (res[0] < 0) res[0] += MOD;
        while (res[1] < 0) res[1] += MOD;
    }
    printf("%03lld\n", (res[0] * 2 - 1 + MOD) % MOD);
}
```

## ex.py

```python
from pwn import *

p = remote("localhost", 8011)
for i in range(10):
    p.recvuntil(b'prob num')
    p.recvline()
    msg = p.recvline()
    p2 = process('./ex')
    p2.send(msg)
    ans = p2.recvline()
    p2.close()
    p.send(ans)
p.interactive()
```