
# one_apple

#### 출제자 : 조수호 / shielder

## Concept

- 다이나믹 프로그래밍

## Writeup

dp table을 dp\[\(총 개수\)\] = \(이를 만족하는 가방의 최소 사용 개수\)로 정의하고, 가방의 개수가 최대 200개이므로 201로 초기화합니다. 초기 상태에 dp\[0\] = 0입니다. 각 가방의 무게는 k\[x\]이고, x번째 가방까지 탐색 완료하고 x+1번쨰 가방을 탐색 중이라고 합시다. 탐색 중인 개수 m\( >= k\[x+1\]\)에 대해서 dp\[m - k\[x+1\]\] != 201이라면, x번째까지의 가방 조합으로 m - k\[x+1\]만큼 들 수 있으므로, x+1번째 가방을 사용하면 m만큼 들 수 있습니다. 따라서 dp table을 min(dp\[m\], dp\[m - k\[x+1\]\] + 1)로 갱신합니다. 시간복잡도가 O(nk)이므로 시간 내에 해결 가능합니다. 탐색 종료 후 dp\[n\]과 dp\[n-1\]을 확인하고 조건에 맞게 출력합니다.


## ex.cpp

```cpp
// compile : /usr/bin/g++ ex.cpp -o ex
#include <iostream>
#include <algorithm>

using namespace std;

int bag[11111], n, k;
int ns[200001];

int main(){
    cin >> n >> k;
    for (int i = 0; i < k; i++) scanf("%d", &bag[i]);
    for(int i = 0; i <= 200000; i++) ns[i] = 201;
    ns[0] = 0;
    for(int i = 0; i < k; i++){
        for(int j = 200000; j >= bag[i]; j--){
            if(ns[j - bag[i]] != 201) ns[j] = min(ns[j - bag[i]] + 1, ns[j]); 
        }
    }

    int ans = 201;
    ans = min(ans, ns[n]);
    ans = min(ans, ns[n - 1]);
    if(ans == 201) printf("-1\n");
    else printf("%d\n", ans);
}
```

## ex.py

```python
from pwn import *

p = remote("localhost", 20102)
for i in range(10):
    p.recvuntil(b'prob num')
    p.recvline()
    msg = p.recvline()
    msg += p.recvline()
    p2 = process('./ex')
    p2.send(msg)
    ans = p2.recvline()
    p2.close()
    p.send(ans)
p.interactive()
```