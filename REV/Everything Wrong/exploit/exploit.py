from pwn import *
from capstone import *
from Crypto.Cipher import ARC4, AES, DES

def has_duplicates(lst):
    return 1 if len(lst) != len(set(lst)) else 0

def aes_ecb_decrypt(key: bytes, ct: bytes) -> bytes:
    if len(ct) % 16 != 0:
        raise ValueError("AES-ECB NoPadding: ciphertext length must be a multiple of 16")
    cipher = AES.new(key, AES.MODE_ECB)
    return cipher.decrypt(ct)

def des_ecb_decrypt(key: bytes, ct: bytes) -> bytes:
    if len(ct) % 8 != 0:
        raise ValueError("DES-ECB NoPadding: ciphertext length must be a multiple of 8")
    cipher = DES.new(key, DES.MODE_ECB)
    return cipher.decrypt(ct)

def rc4_decrypt(key: bytes, ct: bytes) -> bytes:
    cipher = ARC4.new(key)
    return cipher.decrypt(ct)

def xor_bytes(data: bytes, key: bytes) -> bytes:
    return bytes(b ^ key[i % len(key)] for i, b in enumerate(data))

e = ELF('./main', checksec = False)

s = bytes([158, 94, 177, 197, 153, 209, 42, 173, 183, 86, 79, 208, 193, 34, 16, 167, 121, 40, 1, 214, 29, 143, 19, 235, 215, 116, 206, 21, 231, 198, 158, 82, 167, 25, 230, 100, 126, 229, 113, 113, 197, 133, 121, 36, 55, 147, 236, 240])

strings = e.read(0x9004, 0x5460).split(b'\x00')[:-1]
strings = [s.decode() for s in strings][::-1]

for f in strings:
    md = Cs(CS_ARCH_X86, CS_MODE_64)
    elf = ELF(f, checksec = False)
    
    func_addr = elf.symbols['encrypt48']
    func_size = elf.functions['encrypt48'].size
    func_code = elf.read(func_addr, func_size)

    af, df, rf = 0, 0, 0
    for i in md.disasm(func_code, func_addr):
        # print(f"0x{i.address:x}:\t{i.mnemonic}\t{i.op_str}")
        if i.mnemonic == 'push' and i.op_str == 'r14':
            a_xkey = list(elf.read(0x2120, 8))
            a_key = elf.read(0x2130, 16)
            
            s = xor_bytes(s, a_xkey)
            s = aes_ecb_decrypt(a_key, s)
            break
        if i.mnemonic == 'push' and i.op_str == 'r15':
            d_xkey = list(elf.read(0x2380, 8))
            d_key = elf.read(0x2388, 8)
            
            s = xor_bytes(s, d_xkey)
            s = des_ecb_decrypt(d_key, s)
            break
        if i.mnemonic == 'push' and i.op_str == 'rbp':
            r_xkey = list(elf.read(0x2000, 8))
            r_key = elf.read(0x2008, 8)
            
            s = xor_bytes(s, r_xkey)
            s = rc4_decrypt(r_key, s)
            break
print(s.decode())
