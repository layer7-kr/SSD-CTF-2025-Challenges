# SOmething Wrong

## Problem Description
So sometimes I feel so isolated in this society, so I choose to focus on solutions, so that my soul grows stronger, so eventually I become someone who is so resourceful, so motivated, and so extraordinary.

## Concept 
- 스크립팅
- 자동화

## Write-Up
문제 파일을 다운로드 받으면 `main` 바이너리와 함께 1200개의 `.so` 파일들이 주어집니다.

```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int i; // [rsp+0h] [rbp-B0h]
  int j; // [rsp+4h] [rbp-ACh]
  void *handle; // [rsp+8h] [rbp-A8h]
  char *v7; // [rsp+10h] [rbp-A0h]
  void (__fastcall *v8)(char *); // [rsp+18h] [rbp-98h]
  char s[8]; // [rsp+20h] [rbp-90h] BYREF
  __int64 v10; // [rsp+28h] [rbp-88h]
  __int64 v11; // [rsp+30h] [rbp-80h]
  __int64 v12; // [rsp+38h] [rbp-78h]
  __int64 v13; // [rsp+40h] [rbp-70h]
  __int64 v14; // [rsp+48h] [rbp-68h]
  __int64 v15; // [rsp+50h] [rbp-60h]
  __int64 v16; // [rsp+58h] [rbp-58h]
  char dest[8]; // [rsp+60h] [rbp-50h] BYREF
  __int64 v18; // [rsp+68h] [rbp-48h]
  __int64 v19; // [rsp+70h] [rbp-40h]
  __int64 v20; // [rsp+78h] [rbp-38h]
  __int64 v21; // [rsp+80h] [rbp-30h]
  __int64 v22; // [rsp+88h] [rbp-28h]
  __int64 v23; // [rsp+90h] [rbp-20h]
  __int64 v24; // [rsp+98h] [rbp-18h]
  unsigned __int64 v25; // [rsp+A8h] [rbp-8h]

  v25 = __readfsqword(0x28u);
  *(_QWORD *)s = 0LL;
  v10 = 0LL;
  v11 = 0LL;
  v12 = 0LL;
  v13 = 0LL;
  v14 = 0LL;
  v15 = 0LL;
  v16 = 0LL;
  *(_QWORD *)dest = 0LL;
  v18 = 0LL;
  v19 = 0LL;
  v20 = 0LL;
  v21 = 0LL;
  v22 = 0LL;
  v23 = 0LL;
  v24 = 0LL;
  initialize(argc, argv, envp);
  printf("Input: ");
  __isoc99_scanf("%63s", s);
  if ( strlen(s) != 40 )
    exit(1);
  strncpy(dest, s, 0x28uLL);
  for ( i = 0; i <= 1199; ++i )
  {
    handle = dlopen((&files)[i], 2);
    v7 = dlerror();
    if ( !handle )
    {
      printf("%s", v7);
      puts("Failed to load a library.");
      exit(1);
    }
    v8 = (void (__fastcall *)(char *))dlsym(handle, "func");
    if ( !v8 )
    {
      puts("Failed to load a function.");
      exit(1);
    }
    v8(dest);
    dlclose(handle);
  }
  for ( j = 0; j <= 39; ++j )
  {
    if ( dest[j] != ans[j] )
    {
      puts("Wrong.");
      exit(1);
    }
  }
  puts("Correct!");
  printf("FLAG: %s\n", s);
  return 0;
}
```

해당 바이너리를 보면 위와 같은데 문자열을 하나 입력 받고 1200개의  `.so` 파일에서 `func` 함수를 가져와 암호화한 뒤 `ans`라는 배열과 비교하는 것을 알 수 있습니다. `.so` 파일들의 순서는 바이너리 내에 하드코딩돼 있습니다.

```txt
-rwxr-xr-x 1 tuplest tuplest 17168 Aug  9 13:40 fc4ab248.so
-rwxr-xr-x 1 tuplest tuplest 17192 Aug  9 13:40 fc62f7c1.so
-rwxr-xr-x 1 tuplest tuplest 17168 Aug  9 13:40 fc638d29.so
-rwxr-xr-x 1 tuplest tuplest 17168 Aug  9 13:40 fc8b53ae.so
-rwxr-xr-x 1 tuplest tuplest 17168 Aug  9 13:40 fcfe291b.so
-rwxr-xr-x 1 tuplest tuplest 16792 Aug  9 13:39 fd26f4c0.so
-rwxr-xr-x 1 tuplest tuplest 17168 Aug  9 13:40 fd332938.so
-rwxr-xr-x 1 tuplest tuplest 17192 Aug  9 13:40 fd4a8503.so
-rwxr-xr-x 1 tuplest tuplest 17168 Aug  9 13:40 fda34541.so
-rwxr-xr-x 1 tuplest tuplest 17192 Aug  9 13:40 fe15949c.so
-rwxr-xr-x 1 tuplest tuplest 17168 Aug  9 13:40 fe41a037.so
-rwxr-xr-x 1 tuplest tuplest 16792 Aug  9 13:39 fe680b87.so
-rwxr-xr-x 1 tuplest tuplest 17192 Aug  9 13:41 fe6b5548.so
-rwxr-xr-x 1 tuplest tuplest 17168 Aug  9 13:40 fe9f5b44.so
-rwxr-xr-x 1 tuplest tuplest 17192 Aug  9 13:41 ff3733cd.so
-rwxr-xr-x 1 tuplest tuplest 17192 Aug  9 13:40 ff4fd275.so
-rwxr-xr-x 1 tuplest tuplest 17192 Aug  9 13:41 ffa4d5f2.so
-rwxr-xr-x 1 tuplest tuplest 16792 Aug  9 13:39 fffac8ee.so
```

해당 `.so` 파일들을 살펴보면 일정한 사이즈의 3종류가 존재한다는 것을 알 수 있습니다.

```c
int __cdecl func(char *s)
{
  __int64 v1; // rbx
  __int64 v2; // rbx
  int i; // [rsp+18h] [rbp-48h]
  char tmp[40]; // [rsp+20h] [rbp-40h]
  unsigned __int64 v6; // [rsp+48h] [rbp-18h]

  v6 = __readfsqword(0x28u);
  for ( i = 0; i <= 39; ++i )
    tmp[(i + 9) % 40] = s[i];
  v1 = *(_QWORD *)&tmp[8];
  *(_QWORD *)s = *(_QWORD *)tmp;
  *((_QWORD *)s + 1) = v1;
  v2 = *(_QWORD *)&tmp[24];
  *((_QWORD *)s + 2) = *(_QWORD *)&tmp[16];
  *((_QWORD *)s + 3) = v2;
  *((_QWORD *)s + 4) = *(_QWORD *)&tmp[32];
  return 0;
}
```

예를 들어 한 `.so` 파일을 연 후, `func` 함수를 보면 위와 같이 이루어져 있는데 인자로 들어온 문자열을 오른쪽으로 9칸 씩 미는 연산을 하고 있는 것을 볼 수 있습니다.

이와 같이 문자열을 인자로 받아 암호화를 가하는 `func`함수가 `add`, `xor`, `shr`의 세 종류로 존재하는 것을 볼 수 있습니다. 따라서 어떤 순서로, 어떤 연산을, 어떤 값을 통해 이루어지는지 파악한 후 거꾸로 수행하면 플래그를 구할 수 있다는 것을 유추할 수 있습니다.

```py
from pwn import *
from capstone import *

def rol(n):
    s[n:] + s[:n]

def sub(n):
    for i in range(len(s)):
        s[i] -= n
        s[i] &= 0xff

def xor(n):
    for i in range(len(s)):
        s[i] ^= n

e = ELF('./main', checksec = False)

strings = e.read(0x9004, 0x5460).split(b'\x00')[:-1]
strings = [s.decode() for s in strings][::-1]

s = [207, 188, 245, 232, 151, 198, 207, 246, 75, 106, 245, 199, 75, 232, 225, 188, 75, 154, 216, 51, 49, 49, 72, 121, 151, 207, 225, 180, 246, 198, 198, 151, 219, 198, 75, 154, 207, 246, 232, 199]

for f in strings:
    md = Cs(CS_ARCH_X86, CS_MODE_64)
    
    elf = ELF(f, checksec = False)
    func_addr = elf.symbols['func']
    func_size = elf.functions['func'].size
    func_code = elf.read(func_addr, func_size)
    
    xor_cnt = 0
    for i in md.disasm(func_code, func_addr):
        # print(f"0x{i.address:x}:\t{i.mnemonic}\t{i.op_str}")
        
        if i.mnemonic == 'mov' and i.op_str.startswith('dword ptr [rbp - 0x44],'):
            rol(int(i.op_str[24:], 16))
            break
        if i.mnemonic == 'lea' and i.op_str.startswith('ecx, [rax'):
            sub(int(i.op_str[10:11] + i.op_str[12:-1], 16))
            break
        if i.mnemonic == 'xor' and i.op_str.startswith('eax,'):
            xor_cnt += 1
            if xor_cnt < 2: continue
            xor(int(i.op_str[5:], 16) & 0xff)
            break

print(''.join([chr(c) for c in s]))
```

연산은 모든 항의 똑같이 수행되고, 입력값의 순서가 무작위로 변하는 것이 아닌 오른쪽으로 밀릴 뿐이기에 `shr` 연산은 역연산할 필요가 없습니다. `main` 바이너리에서 하드코딩된 순서를 파싱하여 거꾸로 뒤집어준 후, 파일에서 코드를 추출하여 그에 맞는 역연산을 가함으로써 플래그를 구할 수 있습니다.