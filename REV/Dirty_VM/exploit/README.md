# 2025 SSD CTF - Dirty VM
- - -
- Write-Up Author: le0s1mba
- Flag: SSD{W3lc0me_2_VM_Challenge_2025}
- - -
## Challenge Description:
- - -
> 해당 문제는 암호화를 진행하는 opcode를 분석하여 이미 암호화 된 flag를 복호화하는 문제이다.
## Write Up
- - -
Dirty VM 문제는 prob, opcode가 제공된다.
prob은 실행되면서 먼저 opcode를 읽어 opcode 배열에 그래도 로드하고, 사용자가 넘긴 .ssd 파일의 매직 넘버 "SSD"를 확인한 뒤 매직 넘버 뒤의 문자열을 메모리에 적재한다.

파일의 매직 넘버가 검증되면 run_vm() 함수가 호출되어 opcode를 실행하기 시작한다.
VM은 0x12를 만나면 종료하는데, 종료 직전에 run_vm 내부의 데이터 배열이 암호화된 플래그 값과 일치해야 "correct!"가 출력된다.

opcode를 분석해 보면 초기화 구간에서 R0을 0으로 만들고 R1에 0x20, R2에 0x41, R3에 0x2A를 각각 넣은 뒤, R0이 0x20에 도달할 때까지 루프를 돌며 flag[R0]에 0x41을 더한 뒤 해당 값에 0x2A를 xor하는 연산을 진행한다.

즉, 정리하자면
```python
enc = (orig + 0x41) ^ 0x2A
```
이다.
따라서 복호화는
```python
dec = (enc ^ 0x2A) - 0x41
```
을 그대로 적용해주면 된다.

```python
enc = "bebeaf96b25e878e5b848c8a598abda48aae838887878c85828c8a595b595c94"
dec = list(((int(enc[i:i+2], 16) ^ 0x2A) - 0x41) & 0xFF for i in range(0, len(enc), 2))
print(''.join(chr(i) for i in dec))
```
다음과 같이 복호화 코드를 작성하여 실행하게 되면 SSD{W3lc0me_2_VM_Challenge_2025}라는 문자열이 복구되며, 이를 제출하면 정답이 확인된다.